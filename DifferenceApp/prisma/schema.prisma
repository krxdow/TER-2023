// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}


// Un compte est représenter par un utilisateur, 
model Account {
  id_account         String    @id @default(cuid())
  providerType       String
  providerId         String
  providerAccountId  String
  refreshToken       String?
  accessToken        String?
  accessTokenExpires DateTime?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  user               User     @relation(fields: [idUser], references: [id_user], onDelete: Cascade)
  idUser             String

  @@unique([providerId, providerAccountId])
}

// Session représente la connexion d'un utilisateur
model Session {
  id_session   String   @id @default(cuid())            // id de la session
  expires      DateTime                                 // date à laquel la session exprie
  sessionToken String   @unique
  accessToken  String   @unique
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user         User     @relation(name: "Useressions", fields: [idUser], references: [id_user])   //la session est associé à un utilisateur
  idUser       String
}

model User {
  id_user       String    @id @default(cuid())
  email         String    @unique
  frist_name    String?
  last_name     String?
  age           Int
  birthday      DateTime
  password      String                                    // todo: hash password or encrypt method
  emailVerified DateTime?                                 // ???
  image         String?                                   // photo de profil ???
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  accounts      Account[]                                             // ???
  sessions      Session[]       @relation(name: "Useressions")             // un utilisateur a une liste de session
  games         Game[]          @relation(name: "UserGames")                // un utilisateur a plusieurs jeux
  gamesPlayed   GamesPlayed[]   @relation(name: "UserGamesPlayed")     // un utilisateur joue a plusieursparties
}


// TODO: link Admin to User model
model Admin {
  id_admin   Int      @id @default(autoincrement())
  email      String   @unique
  frist_name String?
  last_name  String?
  born       DateTime
  password   String
  age        Int
}


  // Liste de chaque données qu'un utilisateur peut avoir

model Game {

  id_game         Int             @id @default(autoincrement())
  // Premier terme
  firstTerme      Entites         @relation("firstEntite", fields: [idFirstTerm], references: [id_entite])
  idFirstTerm     Int             @unique
  // Second terme
  secondTerme     Entites         @relation("secondEntite", fields: [idSecondTerm], references: [id_entite])
  idSecondTerm    Int             @unique
  // Utilisateur
  user            User            @relation(name: "UserGames", fields: [idUser], references: [id_user])
  idUser          String          @unique
  // Données autre
  number_of_play  Int                               // nombre de personne qui ont joué
  is_ajoute       Boolean         @default(false)   // si le jeu a été ajouté par l'admin ou par les autres

  // Liste de chaque données qu'un jeu peut avoir
  differences     Differences[]   @relation(name: "GameDifference")   // un jeu peut avoir plusieurs differences
  gamePlayed      GamesPlayed[]   @relation(name: "GameGamesPlayed")  // un jeu est dans plusieurs parties joué


}

// Tale de demande de verification d'identité
model VerificationRequest {
  id_verif      String   @id @default(cuid())
  identifier    String
  token         String   @unique
  expires       DateTime
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([identifier, token])
}

// Table sur les entités existantent
model Entites{
  id_entite     Int       @id @default(autoincrement())
  nom_entite    String
  categorie     String
  is_ajoute     Boolean   @default(false)
  entite1Games  Game[]    @relation(name: "firstEntite")    //une entite est présente en tant que premier terme dans plusieurs jeux
  entite2Games  Game[]    @relation(name: "secondEntite")   //une entite est présente en tant que second terme dans plusieurs jeux 
}

// Table sur les différences qui existe 
model Differences {
  id_diff       Int       @id @default(autoincrement())
  type_diff     String    @default("CARACTERISTIQUE")   //autre possiblité etant lieu et couleur
  valeur_diff   String
  game          Game      @relation("GameDifference", fields: [idGame], references: [id_game])
  idGame        Int       @unique
}

// Table qui caracterise les parties joué
model GamesPlayed{
  // Jeu
  idGame        Int       @unique
  game          Game      @relation("GameGamesPlayed", fields: [idGame], references: [id_game])
  // Joueur
  idPlayer      String    @unique
  player        User      @relation("UserGamesPlayed", fields: [idPlayer], references: [id_user])
  // Information sur la partie
  startplay     DateTime      // la date à laquelle la partie à commencé
  is_fini       Boolean       // si la partie est fini
  pourcentage   Int           // pourcentage de réponse attendu
  score         Int           // score obtenue après calcul
}